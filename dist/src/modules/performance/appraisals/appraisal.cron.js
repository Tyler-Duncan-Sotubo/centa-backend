"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var AutoCreatePerformanceCronService_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.AutoCreatePerformanceCronService = void 0;
const common_1 = require("@nestjs/common");
const schedule_1 = require("@nestjs/schedule");
const company_service_1 = require("../../core/company/company.service");
const performance_settings_service_1 = require("../performance-settings/performance-settings.service");
const date_fns_1 = require("date-fns");
const appraisal_cycle_service_1 = require("./appraisal-cycle.service");
const appraisals_service_1 = require("./appraisals.service");
const employees_service_1 = require("../../core/employees/employees.service");
let AutoCreatePerformanceCronService = AutoCreatePerformanceCronService_1 = class AutoCreatePerformanceCronService {
    constructor(companyService, settingsService, cycleService, appraisalService, employeeService) {
        this.companyService = companyService;
        this.settingsService = settingsService;
        this.cycleService = cycleService;
        this.appraisalService = appraisalService;
        this.employeeService = employeeService;
        this.logger = new common_1.Logger(AutoCreatePerformanceCronService_1.name);
    }
    async handlePerformanceAutomation() {
        const companies = await this.companyService.getAllCompanies();
        const MAX_APPRAISALS_PER_COMPANY = 100;
        for (const company of companies) {
            const settings = await this.settingsService.getAllPerformanceSettings(company.id);
            const autoCreateCycles = settings.autoCreateCycles ?? true;
            const autoCreateAppraisals = settings.autoCreateAppraisals ?? true;
            const frequency = settings.appraisalFrequency ?? 'quarterly';
            const now = new Date();
            let currentCycle = await this.cycleService.findCurrent(company.id);
            if (autoCreateCycles) {
                const latestCycle = await this.cycleService.getLastCycle(company.id);
                if (!latestCycle || new Date(latestCycle.endDate) <= now) {
                    const { startDate, endDate, name } = this.generateNextCycleRange(frequency, latestCycle?.endDate ? new Date(latestCycle.endDate) : now);
                    currentCycle = await this.cycleService.create({
                        name,
                        startDate,
                        endDate,
                        isAutoGenerated: true,
                        status: 'active',
                    }, company.id);
                    this.logger.log(`Auto-created cycle '${name}' for company ${company.name}`);
                }
            }
            if (autoCreateAppraisals && currentCycle) {
                const employees = await this.employeeService.findAllEmployees(company.id);
                let createdCount = 0;
                for (const employee of employees) {
                    if (createdCount >= MAX_APPRAISALS_PER_COMPANY) {
                        this.logger.warn(`Appraisal creation limit reached (${MAX_APPRAISALS_PER_COMPANY}) for ${company.name}`);
                        break;
                    }
                    try {
                        await this.appraisalService.create({
                            employeeId: employee.id,
                            cycleId: currentCycle.id,
                        }, company.id);
                        this.logger.log(`Created appraisal for ${employee.id} in ${company.name}`);
                        createdCount++;
                    }
                    catch (error) {
                        if (error?.message?.includes('already exists')) {
                            this.logger.debug(`Appraisal already exists for ${employee.id} in ${company.name}`);
                        }
                        else {
                            this.logger.error(`Failed to create appraisal for ${employee.id} in ${company.name}`, error.stack);
                        }
                    }
                }
            }
        }
    }
    generateNextCycleRange(frequency, fromDate, generateCurrent = true) {
        const now = new Date(fromDate);
        let start;
        let end;
        let name;
        switch (frequency) {
            case 'monthly': {
                const base = generateCurrent ? now : (0, date_fns_1.addMonths)(now, 1);
                start = (0, date_fns_1.startOfMonth)(base);
                end = (0, date_fns_1.endOfMonth)(base);
                name = (0, date_fns_1.format)(start, 'MMMM yyyy');
                break;
            }
            case 'quarterly': {
                const currentQuarter = Math.floor(now.getMonth() / 3) + 1;
                const nextQuarter = currentQuarter === 4 ? 1 : currentQuarter + 1;
                const year = now.getFullYear();
                const quarter = generateCurrent ? currentQuarter : nextQuarter;
                const cycleYear = generateCurrent
                    ? year
                    : currentQuarter === 4
                        ? year + 1
                        : year;
                const quarterStartMonth = (quarter - 1) * 3;
                start = new Date(cycleYear, quarterStartMonth, 1);
                end = (0, date_fns_1.endOfQuarter)(start);
                name = `Q${quarter} ${cycleYear}`;
                break;
            }
            case 'biannual': {
                const currentHalf = now.getMonth() < 6 ? 1 : 2;
                const nextHalf = currentHalf === 1 ? 2 : 1;
                const year = now.getFullYear();
                const half = generateCurrent ? currentHalf : nextHalf;
                const cycleYear = generateCurrent
                    ? year
                    : currentHalf === 2
                        ? year + 1
                        : year;
                start =
                    half === 1 ? new Date(cycleYear, 0, 1) : new Date(cycleYear, 6, 1);
                end =
                    half === 1 ? new Date(cycleYear, 5, 30) : new Date(cycleYear, 11, 31);
                name = `H${half} ${cycleYear}`;
                break;
            }
            default: {
                const year = now.getFullYear();
                const cycleYear = generateCurrent ? year : year + 1;
                start = new Date(cycleYear, 0, 1);
                end = new Date(cycleYear, 11, 31);
                name = `Annual ${cycleYear}`;
            }
        }
        return {
            name,
            startDate: (0, date_fns_1.format)(start, 'yyyy-MM-dd'),
            endDate: (0, date_fns_1.format)(end, 'yyyy-MM-dd'),
        };
    }
};
exports.AutoCreatePerformanceCronService = AutoCreatePerformanceCronService;
__decorate([
    (0, schedule_1.Cron)(schedule_1.CronExpression.EVERY_WEEK),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AutoCreatePerformanceCronService.prototype, "handlePerformanceAutomation", null);
exports.AutoCreatePerformanceCronService = AutoCreatePerformanceCronService = AutoCreatePerformanceCronService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [company_service_1.CompanyService,
        performance_settings_service_1.PerformanceSettingsService,
        appraisal_cycle_service_1.AppraisalCycleService,
        appraisals_service_1.AppraisalsService,
        employees_service_1.EmployeesService])
], AutoCreatePerformanceCronService);
//# sourceMappingURL=appraisal.cron.js.map
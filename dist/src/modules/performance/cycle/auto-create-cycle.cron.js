"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var AutoCreateCycleCronService_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.AutoCreateCycleCronService = void 0;
const common_1 = require("@nestjs/common");
const schedule_1 = require("@nestjs/schedule");
const company_service_1 = require("../../core/company/company.service");
const date_fns_1 = require("date-fns");
const performance_settings_service_1 = require("../performance-settings/performance-settings.service");
const cycle_service_1 = require("./cycle.service");
let AutoCreateCycleCronService = AutoCreateCycleCronService_1 = class AutoCreateCycleCronService {
    constructor(settingsService, cycleService, companyService) {
        this.settingsService = settingsService;
        this.cycleService = cycleService;
        this.companyService = companyService;
        this.logger = new common_1.Logger(AutoCreateCycleCronService_1.name);
    }
    async handleAutoCycleCreation() {
        const companies = await this.companyService.getAllCompanies();
        const today = (0, date_fns_1.format)(new Date(), 'yyyy-MM-dd');
        for (const company of companies) {
            try {
                const settings = await this.settingsService.getAllPerformanceSettings(company.id);
                const autoCreate = settings.autoCreateCycles ?? true;
                const frequency = settings.reviewFrequency ?? 'quarterly';
                if (!autoCreate)
                    continue;
                const latestCycle = await this.cycleService.getLastCycle(company.id);
                if (!latestCycle) {
                    const { startDate, endDate, name } = this.generateCycleContainingDate(frequency, new Date());
                    await this.cycleService.create({
                        name,
                        startDate,
                        endDate,
                        description: `Auto-created cycle for ${company.name} for ${frequency} review`,
                        isAutoGenerated: true,
                        status: 'active',
                    }, company.id);
                    this.logger.log(`Auto-created first cycle '${name}' for company ${company.name}`);
                    continue;
                }
                if (latestCycle.endDate >= today) {
                    continue;
                }
                const { startDate, endDate, name } = this.generateNextCycleRange(frequency, new Date(latestCycle.endDate), false);
                await this.cycleService.create({
                    name,
                    startDate,
                    endDate,
                    description: `Auto-created cycle for ${company.name} for ${frequency} review`,
                    isAutoGenerated: true,
                    status: 'active',
                }, company.id);
                this.logger.log(`Auto-created ${name} cycle for company ${company.name}`);
            }
            catch (err) {
                this.logger.error(`Auto cycle creation failed for company ${company?.name ?? company?.id}`, err?.stack ?? String(err));
            }
        }
    }
    generateCycleContainingDate(frequency, date) {
        return this.generateNextCycleRange(frequency, date, true);
    }
    generateNextCycleRange(frequency, fromDate, generateCurrent = true) {
        const now = new Date(fromDate);
        let start;
        let end;
        let name;
        switch (frequency) {
            case 'monthly': {
                const base = generateCurrent ? now : (0, date_fns_1.addMonths)(now, 1);
                start = (0, date_fns_1.startOfMonth)(base);
                end = (0, date_fns_1.endOfMonth)(base);
                name = (0, date_fns_1.format)(start, 'MMMM yyyy');
                break;
            }
            case 'quarterly': {
                const currentQuarter = Math.floor(now.getMonth() / 3) + 1;
                const nextQuarter = currentQuarter === 4 ? 1 : currentQuarter + 1;
                const year = now.getFullYear();
                const quarter = generateCurrent ? currentQuarter : nextQuarter;
                const cycleYear = generateCurrent
                    ? year
                    : currentQuarter === 4
                        ? year + 1
                        : year;
                const quarterStartMonth = (quarter - 1) * 3;
                start = new Date(cycleYear, quarterStartMonth, 1);
                end = (0, date_fns_1.endOfQuarter)(start);
                name = `Q${quarter} ${cycleYear}`;
                break;
            }
            case 'biannual': {
                const currentHalf = now.getMonth() < 6 ? 1 : 2;
                const nextHalf = currentHalf === 1 ? 2 : 1;
                const year = now.getFullYear();
                const half = generateCurrent ? currentHalf : nextHalf;
                const cycleYear = generateCurrent
                    ? year
                    : currentHalf === 2
                        ? year + 1
                        : year;
                start =
                    half === 1 ? new Date(cycleYear, 0, 1) : new Date(cycleYear, 6, 1);
                end =
                    half === 1 ? new Date(cycleYear, 5, 30) : new Date(cycleYear, 11, 31);
                name = `H${half} ${cycleYear}`;
                break;
            }
            default: {
                const year = now.getFullYear();
                const cycleYear = generateCurrent ? year : year + 1;
                start = new Date(cycleYear, 0, 1);
                end = new Date(cycleYear, 11, 31);
                name = `Annual ${cycleYear}`;
            }
        }
        return {
            name,
            startDate: (0, date_fns_1.format)(start, 'yyyy-MM-dd'),
            endDate: (0, date_fns_1.format)(end, 'yyyy-MM-dd'),
        };
    }
};
exports.AutoCreateCycleCronService = AutoCreateCycleCronService;
__decorate([
    (0, schedule_1.Cron)(schedule_1.CronExpression.EVERY_DAY_AT_1AM),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AutoCreateCycleCronService.prototype, "handleAutoCycleCreation", null);
exports.AutoCreateCycleCronService = AutoCreateCycleCronService = AutoCreateCycleCronService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [performance_settings_service_1.PerformanceSettingsService,
        cycle_service_1.CycleService,
        company_service_1.CompanyService])
], AutoCreateCycleCronService);
//# sourceMappingURL=auto-create-cycle.cron.js.map
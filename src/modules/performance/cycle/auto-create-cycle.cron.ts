import { Injectable, Logger } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { CompanyService } from 'src/modules/core/company/company.service';
import {
  format,
  addMonths,
  startOfMonth,
  endOfMonth,
  endOfQuarter,
} from 'date-fns';
import { PerformanceSettingsService } from '../performance-settings/performance-settings.service';
import { CycleService } from './cycle.service';

@Injectable()
export class AutoCreateCycleCronService {
  private readonly logger = new Logger(AutoCreateCycleCronService.name);

  constructor(
    private readonly settingsService: PerformanceSettingsService,
    private readonly cycleService: CycleService,
    private readonly companyService: CompanyService,
  ) {}

  @Cron(CronExpression.EVERY_DAY_AT_1AM)
  async handleAutoCycleCreation() {
    const companies = await this.companyService.getAllCompanies();
    const today = format(new Date(), 'yyyy-MM-dd');

    for (const company of companies) {
      try {
        const settings = await this.settingsService.getAllPerformanceSettings(
          company.id,
        );

        const autoCreate = settings.auto_create_cycles ?? true;
        const frequency = settings.review_frequency ?? 'quarterly';

        if (!autoCreate) continue;

        const latestCycle = await this.cycleService.getLastCycle(company.id);

        /**
         * FIRST CYCLE
         */
        if (!latestCycle) {
          const { startDate, endDate, name } = this.generateCycleContainingDate(
            frequency,
            new Date(),
          );

          try {
            await this.cycleService.create(
              {
                name,
                startDate,
                endDate,
                description: `Auto-created cycle for ${company.name}`,
                isAutoGenerated: true,
                status: 'active',
              } as any,
              company.id,
            );
          } catch (e: any) {
            this.logger.warn(
              `Skip existing '${name}' {for ${company.name}} + ${e.message}`,
            );
          }
          continue;
        }

        /**
         * STILL ACTIVE
         */
        if (latestCycle.endDate >= today) continue;

        /**
         * NEXT
         */
        const { startDate, endDate, name } = this.generateNextCycleRange(
          frequency,
          new Date(latestCycle.endDate),
          false,
        );

        try {
          await this.cycleService.create(
            {
              name,
              startDate,
              endDate,
              description: `Auto-created cycle for ${company.name}`,
              isAutoGenerated: true,
              status: 'active',
            } as any,
            company.id,
          );
        } catch (e: any) {
          this.logger.warn(
            `Skip existing '${name}' for ${company.name} + ${e.message}`,
          );
        }
      } catch (err: any) {
        this.logger.error(
          `Auto cycle failed for ${company?.name ?? company?.id}`,
          err?.stack ?? String(err),
        );
      }
    }
  }

  private generateCycleContainingDate(frequency: string, date: Date) {
    return this.generateNextCycleRange(frequency, date, true);
  }

  private generateNextCycleRange(
    frequency: string,
    fromDate: Date,
    generateCurrent = true,
  ) {
    const now = new Date(fromDate);
    let start: Date;
    let end: Date;
    let name: string;

    switch (frequency) {
      case 'monthly': {
        const base = generateCurrent ? now : addMonths(now, 1);
        start = startOfMonth(base);
        end = endOfMonth(base);
        name = format(start, 'MMM-yyyy').toUpperCase(); // FEB-2026
        break;
      }

      case 'quarterly': {
        const currentQuarter = Math.floor(now.getMonth() / 3) + 1;
        const nextQuarter = currentQuarter === 4 ? 1 : currentQuarter + 1;
        const year = now.getFullYear();

        const quarter = generateCurrent ? currentQuarter : nextQuarter;
        const cycleYear = generateCurrent
          ? year
          : currentQuarter === 4
            ? year + 1
            : year;

        const quarterStartMonth = (quarter - 1) * 3;
        start = new Date(cycleYear, quarterStartMonth, 1);
        end = endOfQuarter(start);
        name = `Q${quarter} ${cycleYear}`;
        break;
      }

      case 'biannual': {
        const currentHalf = now.getMonth() < 6 ? 1 : 2;
        const nextHalf = currentHalf === 1 ? 2 : 1;
        const year = now.getFullYear();

        const half = generateCurrent ? currentHalf : nextHalf;
        const cycleYear = generateCurrent
          ? year
          : currentHalf === 2
            ? year + 1
            : year;

        start =
          half === 1 ? new Date(cycleYear, 0, 1) : new Date(cycleYear, 6, 1);
        end =
          half === 1 ? new Date(cycleYear, 5, 30) : new Date(cycleYear, 11, 31);
        name = `H${half} ${cycleYear}`;
        break;
      }

      default: {
        const year = now.getFullYear();
        const cycleYear = generateCurrent ? year : year + 1;
        start = new Date(cycleYear, 0, 1);
        end = new Date(cycleYear, 11, 31);
        name = `Annual ${cycleYear}`;
      }
    }

    return {
      name,
      startDate: format(start, 'yyyy-MM-dd'),
      endDate: format(end, 'yyyy-MM-dd'),
    };
  }
}

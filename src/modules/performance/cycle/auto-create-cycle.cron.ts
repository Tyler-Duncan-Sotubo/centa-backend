import { Injectable, Logger } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { CompanyService } from 'src/modules/core/company/company.service';
import {
  format,
  addMonths,
  startOfMonth,
  endOfMonth,
  endOfQuarter,
} from 'date-fns';
import { PerformanceSettingsService } from '../performance-settings/performance-settings.service';
import { CycleService } from './cycle.service';

@Injectable()
export class AutoCreateCycleCronService {
  private readonly logger = new Logger(AutoCreateCycleCronService.name);

  constructor(
    private readonly settingsService: PerformanceSettingsService,
    private readonly cycleService: CycleService,
    private readonly companyService: CompanyService,
  ) {}

  @Cron(CronExpression.EVERY_WEEK)
  async handleAutoCycleCreation() {
    const companies = await this.companyService.getAllCompanies();

    for (const company of companies) {
      const settings = await this.settingsService.getAllPerformanceSettings(
        company.id,
      );
      const autoCreate = settings.autoCreateCycles ?? true;
      const frequency = settings.reviewFrequency ?? 'quarterly';

      if (!autoCreate) continue;

      const latestCycle = await this.cycleService.getLastCycle(company.id);
      const now = new Date();

      if (!latestCycle || new Date(latestCycle.endDate) <= now) {
        const { startDate, endDate, name } = this.generateNextCycleRange(
          frequency,
          latestCycle?.endDate ? new Date(latestCycle.endDate) : now,
        );

        await this.cycleService.create(
          {
            name,
            startDate,
            endDate,
            description: `Auto-created cycle for ${company.name} for ${frequency} review`,
            isAutoGenerated: true,
          },
          company.id,
        );

        this.logger.log(
          `Auto-created ${name} cycle for company ${company.name}`,
        );
      }
    }
  }

  private generateNextCycleRange(
    frequency: string,
    fromDate: Date,
    generateCurrent = true,
  ) {
    const now = new Date(fromDate);
    let start: Date;
    let end: Date;
    let name: string;

    switch (frequency) {
      case 'monthly': {
        const base = generateCurrent ? now : addMonths(now, 1);
        start = startOfMonth(base);
        end = endOfMonth(base);
        name = format(start, 'MMMM yyyy');
        break;
      }

      case 'quarterly': {
        const currentQuarter = Math.floor(now.getMonth() / 3) + 1;
        const nextQuarter = currentQuarter === 4 ? 1 : currentQuarter + 1;
        const year = now.getFullYear();

        const quarter = generateCurrent ? currentQuarter : nextQuarter;
        const cycleYear = generateCurrent
          ? year
          : currentQuarter === 4
            ? year + 1
            : year;

        const quarterStartMonth = (quarter - 1) * 3;
        start = new Date(cycleYear, quarterStartMonth, 1);
        end = endOfQuarter(start);
        name = `Q${quarter} ${cycleYear}`;
        break;
      }

      case 'biannual': {
        const currentHalf = now.getMonth() < 6 ? 1 : 2;
        const nextHalf = currentHalf === 1 ? 2 : 1;
        const year = now.getFullYear();

        const half = generateCurrent ? currentHalf : nextHalf;
        const cycleYear = generateCurrent
          ? year
          : currentHalf === 2
            ? year + 1
            : year;

        start =
          half === 1 ? new Date(cycleYear, 0, 1) : new Date(cycleYear, 6, 1);
        end =
          half === 1 ? new Date(cycleYear, 5, 30) : new Date(cycleYear, 11, 31);
        name = `H${half} ${cycleYear}`;
        break;
      }

      default: {
        const year = now.getFullYear();
        const cycleYear = generateCurrent ? year : year + 1;
        start = new Date(cycleYear, 0, 1);
        end = new Date(cycleYear, 11, 31);
        name = `Annual ${cycleYear}`;
      }
    }

    return {
      name,
      startDate: format(start, 'yyyy-MM-dd'),
      endDate: format(end, 'yyyy-MM-dd'),
    };
  }
}

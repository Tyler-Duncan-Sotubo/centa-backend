import { Injectable, Logger } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { CompanyService } from 'src/modules/core/company/company.service';
import {
  format,
  addMonths,
  startOfMonth,
  endOfMonth,
  endOfQuarter,
} from 'date-fns';
import { PerformanceSettingsService } from '../performance-settings/performance-settings.service';
import { CycleService } from './cycle.service';

@Injectable()
export class AutoCreateCycleCronService {
  private readonly logger = new Logger(AutoCreateCycleCronService.name);

  constructor(
    private readonly settingsService: PerformanceSettingsService,
    private readonly cycleService: CycleService,
    private readonly companyService: CompanyService,
  ) {}

  // Run daily so you don't miss month/quarter boundary & you catch new companies fast
  @Cron(CronExpression.EVERY_DAY_AT_1AM) // 01:00 every day
  async handleAutoCycleCreation() {
    const companies = await this.companyService.getAllCompanies();
    const today = format(new Date(), 'yyyy-MM-dd'); // date-only

    for (const company of companies) {
      try {
        const settings = await this.settingsService.getAllPerformanceSettings(
          company.id,
        );

        const autoCreate = settings.autoCreateCycles ?? true;
        const frequency = settings.reviewFrequency ?? 'quarterly';

        if (!autoCreate) continue;

        const latestCycle = await this.cycleService.getLastCycle(company.id);

        // No cycle exists -> create the current cycle that contains today
        if (!latestCycle) {
          const { startDate, endDate, name } = this.generateCycleContainingDate(
            frequency,
            new Date(),
          );

          // Optional: avoid duplicates by name if your service supports it
          await this.cycleService.create(
            {
              name,
              startDate,
              endDate,
              description: `Auto-created cycle for ${company.name} for ${frequency} review`,
              isAutoGenerated: true,
              status: 'active', // remove if your schema doesn't have it
            } as any,
            company.id,
          );

          this.logger.log(
            `Auto-created first cycle '${name}' for company ${company.name}`,
          );
          continue;
        }

        // If latest cycle is still ongoing, do nothing
        // Compare date strings (safe for YYYY-MM-DD)
        if (latestCycle.endDate >= today) {
          continue;
        }

        // Create the next cycle starting after latestCycle.endDate
        const { startDate, endDate, name } = this.generateNextCycleRange(
          frequency,
          new Date(latestCycle.endDate),
          false, // generate NEXT
        );

        await this.cycleService.create(
          {
            name,
            startDate,
            endDate,
            description: `Auto-created cycle for ${company.name} for ${frequency} review`,
            isAutoGenerated: true,
            status: 'active', // remove if your schema doesn't have it
          } as any,
          company.id,
        );

        this.logger.log(
          `Auto-created ${name} cycle for company ${company.name}`,
        );
      } catch (err: any) {
        this.logger.error(
          `Auto cycle creation failed for company ${company?.name ?? company?.id}`,
          err?.stack ?? String(err),
        );
      }
    }
  }

  /**
   * Create the cycle that CONTAINS the provided date.
   * Useful for "first cycle ever" bootstrap.
   */
  private generateCycleContainingDate(frequency: string, date: Date) {
    // For monthly/quarterly/biannual/annual, the "current" cycle is the one containing `date`.
    // This leverages your existing generator with generateCurrent=true.
    return this.generateNextCycleRange(frequency, date, true);
  }

  /**
   * Your existing generator: with generateCurrent=false it produces the NEXT period.
   */
  private generateNextCycleRange(
    frequency: string,
    fromDate: Date,
    generateCurrent = true,
  ) {
    const now = new Date(fromDate);
    let start: Date;
    let end: Date;
    let name: string;

    switch (frequency) {
      case 'monthly': {
        const base = generateCurrent ? now : addMonths(now, 1);
        start = startOfMonth(base);
        end = endOfMonth(base);
        name = format(start, 'MMMM yyyy');
        break;
      }

      case 'quarterly': {
        const currentQuarter = Math.floor(now.getMonth() / 3) + 1;
        const nextQuarter = currentQuarter === 4 ? 1 : currentQuarter + 1;
        const year = now.getFullYear();

        const quarter = generateCurrent ? currentQuarter : nextQuarter;
        const cycleYear = generateCurrent
          ? year
          : currentQuarter === 4
            ? year + 1
            : year;

        const quarterStartMonth = (quarter - 1) * 3;
        start = new Date(cycleYear, quarterStartMonth, 1);
        end = endOfQuarter(start);
        name = `Q${quarter} ${cycleYear}`;
        break;
      }

      case 'biannual': {
        const currentHalf = now.getMonth() < 6 ? 1 : 2;
        const nextHalf = currentHalf === 1 ? 2 : 1;
        const year = now.getFullYear();

        const half = generateCurrent ? currentHalf : nextHalf;
        const cycleYear = generateCurrent
          ? year
          : currentHalf === 2
            ? year + 1
            : year;

        start =
          half === 1 ? new Date(cycleYear, 0, 1) : new Date(cycleYear, 6, 1);
        end =
          half === 1 ? new Date(cycleYear, 5, 30) : new Date(cycleYear, 11, 31);
        name = `H${half} ${cycleYear}`;
        break;
      }

      default: {
        const year = now.getFullYear();
        const cycleYear = generateCurrent ? year : year + 1;
        start = new Date(cycleYear, 0, 1);
        end = new Date(cycleYear, 11, 31);
        name = `Annual ${cycleYear}`;
      }
    }

    return {
      name,
      startDate: format(start, 'yyyy-MM-dd'),
      endDate: format(end, 'yyyy-MM-dd'),
    };
  }
}

import { Injectable, Logger } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { CompanyService } from 'src/modules/core/company/company.service';
import { PerformanceSettingsService } from '../performance-settings/performance-settings.service';
import {
  format,
  addMonths,
  startOfMonth,
  endOfMonth,
  endOfQuarter,
} from 'date-fns';
import { AppraisalCycleService } from './appraisal-cycle.service';
import { AppraisalsService } from './appraisals.service';
import { EmployeesService } from 'src/modules/core/employees/employees.service';

@Injectable()
export class AutoCreatePerformanceCronService {
  private readonly logger = new Logger(AutoCreatePerformanceCronService.name);

  constructor(
    private readonly companyService: CompanyService,
    private readonly settingsService: PerformanceSettingsService,
    private readonly cycleService: AppraisalCycleService,
    private readonly appraisalService: AppraisalsService,
    private readonly employeeService: EmployeesService,
  ) {}

  @Cron(CronExpression.EVERY_WEEK)
  async handlePerformanceAutomation() {
    const companies = await this.companyService.getAllCompanies();
    const MAX_APPRAISALS_PER_COMPANY = 100;

    for (const company of companies) {
      const settings = await this.settingsService.getAllPerformanceSettings(
        company.id,
      );

      const autoCreateCycles = settings.autoCreateCycles ?? true;
      const autoCreateAppraisals = settings.autoCreateAppraisals ?? true;
      const frequency = settings.appraisalFrequency ?? 'quarterly';

      const now = new Date();

      let currentCycle = await this.cycleService.findCurrent(company.id);

      // 1. Auto-create cycle if needed
      if (autoCreateCycles) {
        const latestCycle = await this.cycleService.getLastCycle(company.id);

        if (!latestCycle || new Date(latestCycle.endDate) <= now) {
          const { startDate, endDate, name } = this.generateNextCycleRange(
            frequency,
            latestCycle?.endDate ? new Date(latestCycle.endDate) : now,
          );

          currentCycle = await this.cycleService.create(
            {
              name,
              startDate,
              endDate,
              isAutoGenerated: true,
              status: 'upcoming',
            },
            company.id,
          );

          this.logger.log(
            `Auto-created cycle '${name}' for company ${company.name}`,
          );
        }
      }

      // 2. Auto-create appraisals with rate limit
      if (autoCreateAppraisals && currentCycle) {
        const employees =
          await this.employeeService.findAllCompanyEmployeesSummary(company.id);

        let createdCount = 0;

        for (const employee of employees) {
          if (createdCount >= MAX_APPRAISALS_PER_COMPANY) {
            this.logger.warn(
              `Appraisal creation limit reached (${MAX_APPRAISALS_PER_COMPANY}) for ${company.name}`,
            );
            break;
          }

          try {
            await this.appraisalService.create(
              {
                employeeId: employee.id,
                cycleId: currentCycle.id,
              },
              company.id,
            );
            this.logger.log(
              `Created appraisal for ${employee.id} in ${company.name}`,
            );
            createdCount++;
          } catch (error) {
            if (error?.message?.includes('already exists')) {
              this.logger.debug(
                `Appraisal already exists for ${employee.id} in ${company.name}`,
              );
            } else {
              this.logger.error(
                `Failed to create appraisal for ${employee.id} in ${company.name}`,
                error.stack,
              );
            }
          }
        }
      }
    }
  }

  private generateNextCycleRange(
    frequency: string,
    fromDate: Date,
    generateCurrent = true,
  ) {
    const now = new Date(fromDate);
    let start: Date;
    let end: Date;
    let name: string;

    switch (frequency) {
      case 'monthly': {
        const base = generateCurrent ? now : addMonths(now, 1);
        start = startOfMonth(base);
        end = endOfMonth(base);
        name = format(start, 'MMMM yyyy');
        break;
      }

      case 'quarterly': {
        const currentQuarter = Math.floor(now.getMonth() / 3) + 1;
        const nextQuarter = currentQuarter === 4 ? 1 : currentQuarter + 1;
        const year = now.getFullYear();

        const quarter = generateCurrent ? currentQuarter : nextQuarter;
        const cycleYear = generateCurrent
          ? year
          : currentQuarter === 4
            ? year + 1
            : year;

        const quarterStartMonth = (quarter - 1) * 3;
        start = new Date(cycleYear, quarterStartMonth, 1);
        end = endOfQuarter(start);
        name = `Q${quarter} ${cycleYear}`;
        break;
      }

      case 'biannual': {
        const currentHalf = now.getMonth() < 6 ? 1 : 2;
        const nextHalf = currentHalf === 1 ? 2 : 1;
        const year = now.getFullYear();

        const half = generateCurrent ? currentHalf : nextHalf;
        const cycleYear = generateCurrent
          ? year
          : currentHalf === 2
            ? year + 1
            : year;

        start =
          half === 1 ? new Date(cycleYear, 0, 1) : new Date(cycleYear, 6, 1);
        end =
          half === 1 ? new Date(cycleYear, 5, 30) : new Date(cycleYear, 11, 31);
        name = `H${half} ${cycleYear}`;
        break;
      }

      default: {
        const year = now.getFullYear();
        const cycleYear = generateCurrent ? year : year + 1;
        start = new Date(cycleYear, 0, 1);
        end = new Date(cycleYear, 11, 31);
        name = `Annual ${cycleYear}`;
      }
    }

    return {
      name,
      startDate: format(start, 'yyyy-MM-dd'),
      endDate: format(end, 'yyyy-MM-dd'),
    };
  }
}
